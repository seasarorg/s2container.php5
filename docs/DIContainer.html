<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja"><head>



<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Language" content="ja">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta name="keywords" content="Seasar2, S2Container, DI, AOP, Dependency Injection, Aspect Oriented Programming, The Seasar Foundation, OSS, オープンソースソフトウェア, Java, フレームワーク">
<meta name="description" content="私たちSeasarプロジェクトはオープンソースという仕組みの元、開発者のゆとりを実現できるプロダクトの開発と提供を通じて、ユーザと開発者とが共に喜びを分かち合える環境実現をお手伝いすることを目指し活動しています。 ">
<title>The Seasar Project - S2Container.PHP5</title>

<link rel="stylesheet" type="text/css" href="theme/main.css" media="screen,projection">
<link rel="stylesheet" type="text/css" href="theme/print.css" media="print"></head><body>

<div id="wrapper">

<div id="header">

<div class="line"><span class="hide">spacer</span></div>

<div id="logo">
<h1 id="h01" class="hide">The Seasar Project</h1>
<a href="http://www.seasar.org/">
<img src="images/seasar_logo_blue.gif" alt="The Seasar Project" height="180" width="390">
</a>
</div>

<div id="tool">
</div>

<div id="navi">
<p><font size="-1"><a href="index.html">S2Container.PHP5 ホーム</a> &raquo; ドキュメント &raquo; DIContainer</font></p>
</div>

</div><!-- header -->

<div id="contents_left">

<h2>メニュー</h2>

<h3>ドキュメント</h3>
<ul>
    <li><a href="setup.html">セットアップ</a></li>
    <li><a href="quickstart.html">クイックスタート</a></li>
    <li>DIContainer
        <font size="-2">
        <ul>
            <li><a href="#S2ContainerAppReference">S2ContainerApplicationContext リファレンス</a>
                <ul>
                    <li><a href="#AppImport">クラスのインポート</a></li>
                    <li><a href="#AppContainer">S2Container の生成</a></li>
                    <li><a href="#AppComponent">コンポーネントの選択</a></li>
                    <li><a href="#AppAnnotation">アノテーション</a></li>
                </ul>
            </li>
            <li><a href="#S2ContainerReference">S2Containerリファレンス</a>
                <ul>
                    <li><a href="#CreateFile">作成すべきファイル</a></li>
                    <li><a href="#S2ContainerDefinition">S2Containerの定義</a></li>
                    <li><a href="#S2ContainerCreation">S2Containerの生成</a></li>
                    <li><a href="#getComponent">コンポーネントの取得</a></li>
                    <li><a href="#DIType">Dependency Injectionのタイプ</a>
<!--
                        <ul>
                            <li type="circle"><a href="#ConstructorInjection">コンストラクタ・インジェクション</a></li>
                            <li type="circle"><a href="#SetterInjection">セッター・インジェクション</a></li>
                            <li type="circle"><a href="#MethodInjection">メソッド・インジェクション</a></li>
                        </ul>
-->
                    </li>
                    <li><a href="#Include">S2Container定義の分割とインクルード</a></li>
                    <li><a href="#Namespace">名前空間</a></li>
                    <li><a href="#InstanceMode">インスタンス管理</a></li>
                    <li><a href="#Lifecycle">ライフサイクル</a></li>
                    <li><a href="#AutoBindingMode">自動バインディング</a></li>
                    <li><a href="#UseS2Container">コンポーネントでS2Containerを利用する</a></li>
                    <li><a href="#Aop">AOPの適用</a></li>
                    <li><a href="#Meta">メタデータ</a></li>
                </ul>
            </li>
            <li><a href="#DefReference">S2Container定義タグリファレンス</a>
                <ul>
                    <li><a href="#DOCTYPE">DOCTYPE</a></li>
                    <li><a href="#componentsTag">componentsタグ</a></li>
                    <li><a href="#includeTag">includeタグ</a></li>
                    <li><a href="#componentTag">componentタグ</a></li>
                    <li><a href="#argTag">argタグ</a></li>
                    <li><a href="#propertyTag">propertyタグ</a></li>
                    <li><a href="#metaTag">metaタグ</a></li>
                    <li><a href="#initMethodTag">initMethodタグ</a></li>
                    <li><a href="#destroyMethodTag">destroyMethodタグ</a></li>
                    <li><a href="#aspectTag">aspectタグ</a></li>
                    <li><a href="#interTypeTag">interTypeタグ</a></li>
                    <li><a href="#descriptionTag">descriptionタグ</a></li>
                </ul>
            </li>
            <li><a href="#constant-def">S2Containerで使用される定数</a>
                <!--
                <ul>
                    <li><a href="#const-dom-valid">S2CONTAINER_PHP5_DOM_VALIDATE</a></li>
                    <li><a href="#const-app-dicon">S2CONTAINER_PHP5_APP_DICON</a></li>
                    <li><a href="#const-log-level">S2CONTAINER_PHP5_LOG_LEVEL</a></li>
                    <li><a href="#const-log-eval">S2CONTAINER_PHP5_DEBUG_EVAL</a></li>
                    <li><a href="#const-log-file">S2CONTAINER_PHP5_SIMPLE_LOG_FILE</a></li>
                    <li><a href="#const-anno">S2CONTAINER_PHP5_ANNOTATION_HANDLER</a></li>
                    <li><a href="#const-env">S2CONTAINER_PHP5_ENV</a></li>
                </ul>
                -->
            </li>
            <li><a href="#Example">Example</a>
                <ul>
                    <li><a href="#ConstructorInjectionEx">コンストラクタ・インジェクション</a></li>
                    <li><a href="#SetterInjectionEx">セッター・インジェクション</a></li>
                    <li><a href="#MethodInjectionEx">メソッド・インジェクション</a></li>
                    <li><a href="#AutoConstructorInjectionEx">自動バインディング(コンストラクタ・インジェクション)</a></li>
                    <li><a href="#AutoSetterInjectionEx">自動バインディング(セッター・インジェクション)</a></li>
                </ul>
            </li>
        </ul>
        </font>
    </li>
    <li><a href="aop.html">AOP</a></li>
    <li><a href="extension.html">Extension</a></li>
    <li><a href="php.html">PHP式</a></li>
</ul>

<h3>リンク</h3>
<ul>
    <li><a href="http://www.seasar.org/">Seasar.org</a></li>
    <li><a href="http://svn.seasar.org/browse/?root=s2container.php5">SVN リポジトリブラウザ</a></li>
    <li><a href="https://www.seasar.org/svn/s2container.php5/">SVN リポジトリ</a></li>
    <li><a href="https://www.seasar.org/issues/browse/CONTAINERPHP">Issue Tracker</a></li>
    <li><a href="http://labs.s2php5.jp/">labs.s2php5.jp</a></li>
</ul>

<h2>PHP プロジェクト</h2>

<h3>Seasar.PHP</h3>

<ul>
    <li><a href="http://s2container.php5.seasar.org/">S2Container.PHP5</a></li>
    <li><a href="http://s2dao.php5.seasar.org/">S2Dao.PHP5</a></li>
</ul>

<h3>Sandbox.PHP</h3>

<ul>
    <li><a href="http://s2ana.php5.sandbox.seasar.org/">S2AnA.PHP5</a></li>
    <li><a href="http://kunit.jp/maple/">Maple.PHP</a></li>
    <li><a href="http://s2base.php5.sandbox.seasar.org/">S2Base.PHP5</a></li>
</ul>



</div><!-- contents_left -->

<div id="contents_center">

<div id="article">
<div class="section">
<h2 id="h02"><a name="S2ContainerAppReference">S2ContainerApplicationContext リファレンス</a></h2>
<p>
</p>

<a name="AppImport"><b><h3>クラスのインポート</h3></b></a>
<p>
　クラスのインポートは次のメソッドで行います。
</p>
<pre>
S2ContainerApplicationContext::import($path, $subDir = false, $pear = false)
</pre>

<ul>
<li>第1引数 : ディレクトリパス</li>
<li>第2引数 : サブディレクトリ検索を行うかどうかを指定</li>
<li>第3引数 : PEAR パッケージ形式のクラスファイルかどうかを指定</li>
</ul>

<p>
　第1引数で指定したディレクトリにあるクラスファイル( .php、.class.php など)、ダイコンファイル( .dicon )をインポートします。インポートではクラス名とクラスファイルのパスを取得します。この情報は autoload 関数でクラス定義が require される際に使用されます。クラス名はクラスファイル名の拡張子を除く部分になります。
クラスファイル名が S2Container.php や S2Container.class.php の場合、「 S2Container 」がクラス名になります。
第2引数、第3引数を true と設定した場合、サブディレクトリを検索しPEAR パッケージ形式のクラスファイルとしてインポート
します。
</p>

<a name="AppContainer"><b><h3>S2Container の生成</h3></b></a>
<p>
　S2Container インスタンスの生成は次のメソッドで行います。
</p>

<pre>
S2ContainerApplicationContext::create()
</pre>

<p>
　生成される S2Container は、import メソッドでインポートされた全クラスをコンポーネントとして持ちます。
import メソッドが実行されていない場合は、コンポーネントを持たない空の S2Container インスタンスが戻ります。
import メソッドで取得されたダイコンファイルについては、そのダイコンファイルを用いて S2Container を生成し、
子コンテナとして include します。
</p>

<a name="AppComponent"><b><h3>コンポーネントの選択</h3></b></a>
<p>
　create メソッドで S2Container を生成する際に、インポートされたクラスやダイコンファイルから一部を選択することができます。
</p>
<ul>
<li>default (パターン設定無し) : インポートされた全てのクラスをコンポーネントとして扱い、全てのダイコンファイルを子コンテナとして include します。</li>
<li>Include Pattern : インポートされたクラスファイルとダイコンファイルに対してパターンにマッチ( preg_match )するもののみを使用します。</li>
<li>Exclude Pattern : インポートされたクラスファイルとダイコンファイルに対してパターンにマッチ( preg_match )するものは除外します。</li>
<li>Include &amp; Exclude : Include Pattern と Exclude Pattern が両方設定されている場合は、Include Pattern にマッチしたものから Exclude Pattern にマッチしたものが除外されます。</li>
</ul>

<b><h4>setIncludePattern メソッド</h4></b>
<pre>
S2ContainerApplicationContext::setIncludePattern($pattern = array())
</pre>
<ul>
<li>第1引数 : 正規表現文字列、またはその配列</li>
</ul>

<p>
　引数の正規表現は preg_match 関数で使用されます。クラス名が「 Bean 」で終わっているクラスを含めたい場合は、引数値は「 /Bean\./ 」となります。
</p>

<p>
　setIncludePattern メソッドは、現在設定されている Include Pattern を上書きします。
</p>

<b><h4>addIncludePattern メソッド</h4></b>
<pre>
S2ContainerApplicationContext::addIncludePattern($pattern)
</pre>

<ul>
<li>第1引数 : 正規表現文字列</li>
</ul>

<p>
　addIncludePattern メソッドは、現在設定されている Include Pattern にパターンを追加します。
</p>

<b><h4>setExcludePattern メソッド</h4></b>
<pre>
S2ContainerApplicationContext::setExcludePattern($pattern)
</pre>

<ul>
<li>第1引数 : 正規表現文字列、またはその配列</li>
</ul>

<p>
　引数の正規表現は preg_match 関数で使用されます。クラス名が「 Abstract 」を含むクラスを除外する場合は、引数値は「 /Abstract/ 」となります。
</p>

<p>
　setExcludePattern メソッドは、現在設定されている Exclude Pattern を上書きします。
</p>

<b><h4>addExcludePattern メソッド</h4></b>
<pre>
S2ContainerApplicationContext::addEcludePattern($pattern)
</pre>
<ul>
<li>第1引数 : 正規表現文字列</li>
</ul>

<p>
　addExcludePattern メソッドは、現在設定されている Exclude Pattern にパターンを追加します。
</p>


<a name="AppAnnotation"><b><h3>アノテーション</h3></b></a>
<p>
　コンポーネントの細かい設定や、Dependency Injection 設定、Aspect の適用を行う場合はアノテーションを用います。
アノテーションの形式は、@アノテーション名[()] です。アットマーク(@)で開始します。末尾はスペース、または改行となります。
アノテーションでは引数を記述することができます。引数の形式は、PHP 配列と同じフォーマットです。
</p>

<b><h4>@S2Component アノテーション</h4></b>
<p>
　コンポーネント情報を設定します。
</p>
<ul>
<li>アノテーションの表記 : @S2Component</li>
<li>引数<br>
  <ul>
  <li>name : コンポーネント名</li>
  <li>instance : <a href="#InstanceMode">インスタンスモードタイプ</a></li>
  <li>autoBinding : <a href="#AutoBindingMode">バインディングモードタイプ</a></li>
  </ul>
</li>
<li>注釈ポイント : クラス</li>
<li>サンプル<br>
<pre>
  /**
   * @S2Component('name' =&gt; 'hoge')
   */
 
  /**
   * @S2Component('name' =&gt; 'hoge', 'instance' =&gt; 'singleton', 'autoBinding' =&gt; 'auto')
   */
</pre>
</li>
</ul>

<b><h4>@S2Binding アノテーション</h4></b>
<p>
　手動インジェクション設定を行います。
</p>
<ul>
<li>アノテーションの表記 : @S2Binding</li>
<li>引数 : インジェクションするコンポーネント名、または Expression</li>
<li>注釈ポイント : セッターメソッド</li>
<li>サンプル<br>
<pre>
  /**
   * @S2Binding('hoge')
   */
  public function setHoge($hoge) {
      $this->hoge = $hoge;
  }
 
  /**
   * @S2Binding('Hello World')
   */
  public funcion setHello($val) {
      $this->hello = $val;
  }
</pre>
</li>
</ul>

<b><h4>@S2Aspect アノテーション</h4></b>
<p>
　アスペクト情報を設定します。
</p>
<ul>
<li>アノテーションの表記 : @S2Aspect</li>
<li>引数<br>
  <ul>
  <li>interceptor : Interceptorコンポーネント名、または Expression</li>
  <li>pointcut : ポイントカットをカンマ区切りで指定</li>
  </ul>
</li>
<li>注釈ポイント : クラス、メソッド</li>
<li>サンプル<br>
<pre>
  /**
   * @S2Aspect('interceptor' => 'traceInterceptor',
   *           'pointcut'    => '.+Action')
   */
  class CdController {
      public function indexAction(){
          ・・・
      }
  }

  class DvdController {
      /**
       * @S2Aspect('interceptor' => 'new S2Container_TraceInterceptor()')
       */
      public funcion indexAction() {
          ・・・
      }
  }
</pre>
</li>
</ul>

</div>


<br>
<div class="section">
<h2 id="h02"><a name="S2ContainerReference">S2Container リファレンス</a></h2>

<a name="CreateFile"><b><h3>作成すべきファイル</h3></b></a>
<p>
　S2Containerを使用するためには、定義ファイルを作成する必要があります。
定義ファイルは、コンポーネントを組み立てるための設計書のようなものです。
定義ファイルの拡張子は .dicon、または .xml です。diconは「ダイコン」と読みます
</p>

<a name="S2ContainerDefinition"><b><h3>S2Containerの定義</h3></b></a>
<p>
　S2Containerの定義は、次のようになります。
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component name="..." class="..."&gt;
            ...
    &lt;/component&gt;
    &lt;component name="..." class="..."&gt;
            ...
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>
DOCTYPEは省略できません。diconファイルを作成する場合は、上記のサンプルをコピー＆ペーストしてください。
ルートは<a href="#componentsTag">componentsタグ</a>です。コンポーネントごとに、
<a href="#componentTag">componentタグ</a>を定義していきます。componentタグの
class属性でコンポーネントのクラス名を指定します。name属性には、コンポーネント名を指定します。
詳細は、<a href="#DefReference">S2Container定義タグリファレンス</a>を参照してください。
</p>

<pre>&lt;components&gt;
    &lt;component name="hoge" class="HogeImpl"/&gt;
&lt;/components&gt;
</pre>


<a name="S2ContainerCreation"><h3>S2Containerの生成</h3></a>
<p>
　S2Containerを作成する場合は、次のメソッドを使用します。<br><br>
　　- S2ContainerFactory#create($path)<br><br>
引数$pathは設定ファイルのパスです。
</p>

<pre>&lt;?php
$PATH = "path/to/ccc.dicon";
...
$container = S2ContainerFactory::create($PATH);
?&gt;
</pre>


<a name="getComponent"><h3>コンポーネントの取得</h3></a>
<p>
　S2Containerからコンポーネントを取り出すには、次のメソッドを使用します。<br><br>
　　- S2Container#getComponent($componentKey)<br><br>
引数には、コンポーネントのクラスもしくはコンポーネント名を指定できます。
詳しくは、<a href="#componentTag">componentタグ</a>を参照してください。
コンポーネントのクラスを指定する場合、コンポーネント instanceof クラスが true を返すクラスなら
指定することができます。しかし、S2Containerの中に指定したクラスを実装しているコンポーネントが複数ある
場合、S2Containerは、どのコンポーネントを返せばよいのか判断できないため、
TooManyRegistrationRuntimeExceptionが発生します。実装コンポーネントがユニークに決まるクラスを指定してくださ
い。コンポーネント名で取得することもできます。その場合も、同一の名前をもつコンポーネントが複数登録されている場合、
TooManyRegistrationRuntimeExceptionが発生します。
</p>

<p>例） 以下のように Hoge クラスがコンポーネント名 hoge で設定されているとします。</p>
<pre>&lt;components&gt;
    &lt;component name="hoge" class="Hoge"/&gt;
&lt;/components&gt;
</pre>

<p>クラスを指定してコンポーネントを取得する場合</p>
<pre>&lt;?php
$container = S2ContainerFactory::create($PATH);
$hoge = $container->getComponent('Hoge');
?&gt;
</pre>

<p>コンポーネント名を指定してコンポーネントを取得する場合</p>
<pre>&lt;?php
$container = S2ContainerFactory::create($PATH);
$hoge = $container->getComponent('hoge');
?&gt;
</pre>

<a name="DIType"><h3>Dependency Injectionのタイプ</h3></a>
<p>　Dependency Injectionには以下のタイプがあります。

<table border="0" vspace="0" hspace="0" cellpadding="0" cellspacing="0">
<tr><td width="15"></td><td> - Constructor Injection</td><td width="15"></td><td>コンポーネントの構成に必要な値をコンストラクタで設定する</td><tr>
<tr><td></td><td> - Setter Injection</td><td></td><td>コンポーネントの構成に必要な値をセッター・メソッドで設定する</td><tr>
<tr><td></td><td> - Method Injection</td><td></td><td>コンポーネントの構成に必要な値を初期化メソッドで設定する</td><tr>
</table>
<br>
MethodInjectionはS2のオリジナルです。S2はすべてのタイプとそのハイブリッド型もサポートします。
</p>

<a name="ConstructorInjection"><b><h3>コンストラクタ・インジェクション</h3></b></a>
<p>
　コンストラクタ・インジェクションとは、任意のコンストラクタの引数値にDependency Injectionします。<br>
S2Containerの定義ファイルには、次の内容を記述します。
</p>
<ul>
    <li>コンポーネントの指定<br>
        コンポーネントは、componentタグで組み立てます。class属性でクラス名を指定します。<br>
        name属性でコンポーネントに名前を付けることもできます。
    </li>
    <li>コンストラクタの引数の指定<br>コンポーネントのコンストラクタの引数は、
        componentタグの子タグであるargタグを使って指定します。<br>
        文字列の場合は、ダブルコーテーション(")で囲みます。
    </li>
</ul>

<pre>&lt;components&gt;
    &lt;component name="..." class="..."&gt;
          &lt;arg&gt;...&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

詳しい使用方法は、Exampleの<a href="#ConstructorInjectionEx">コンストラクタ・インジェクション</a>を参照してください。<br><br>

<a name="SetterInjection"><b><h3>セッター･インジェクション</h3></b></a>
<p>
　セッター･インジェクションとは、任意のプロパティにセッターメソッドを使用してDependency Injectionします。<br>
S2Containerの定義ファイルには、次の内容を記述します。
</p>

<ul>
    <li>コンポーネントの指定<br>
        コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br>
        name属性でコンポーネントに名前を付けることもできます。
    </li>
    <li>プロパティの指定<br>
        コンポーネントのプロパティは、componentタグの子タグであるpropertyタグを使って指定します。<br>
        name属性でプロパティ名を指定します。
    </li>
</ul>

<pre>&lt;components&gt;
    &lt;component name="..." class="..."&gt;
          &lt;property name="..."&gt;...&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

詳しい使用方法は、Exampleの<a href="#SetterInjectionEx">セッター･インジェクション</a>を参照してください。<br>

<a name="MethodInjection"><b><h3>メソッド・インジェクション</h3></b></a>
<p>
　メソッド・インジェクションとは、任意のメソッドを呼び出して、Dependency Injectionします。<br>
S2Containerの定義ファイルには、次の内容を記述します。
</p>

<ul>
    <li>コンポーネントの指定<br>
        コンポーネントの指定は、コンストラクタ・インジェクションと同様です。<br>
        name属性でコンポーネントに名前を付けることもできます。
    </li>
    <li>初期化メソッドの指定<br>
        initMethodタグを使って、コンポーネントの任意のメソッドを呼び出します。
        name属性で、メソッド名を指定します。引数は、argタグを子タグに使います。
        name属性を省略して、ボディで、PHP式を使うこともできます。その際、コンポーネント自身は$componentで表します。
    </li>
</ul>

<pre>&lt;componets&gt;
    &lt;component name="..." class="..."&gt;
          &lt;initMethod&gt;...&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

詳しい使用方法は、Exampleの<a href="#MethodInjectionEx">メソッド・インジェクション</a>を参照してください。<br>

<a name="Include"><h3>S2Container定義の分割とインクルード</h3></a>
<p>
　すべてのコンポーネントを1つのファイルに記述すると、直ぐに肥大化してしまい管理が難しくなります。
そのため、コンポーネントの定義を複数に分割する機能と分割された定義をインクルードして1つにまとめる機能が
S2Containerにあります。S2Container定義ファイルのインクルードは次のようにして行います。
</p>

<pre>&lt;components&gt;
    &lt;include path="bar.dicon"/&gt;
&lt;/components&gt;
</pre>

<a href="#includeTag">includeタグ</a>のpath属性で取り込みたいS2Container定義ファイルのパスを指定します。
詳しくは、<a href="#includeTag">includeタグ</a>を参照してください。
コンポーネントの検索順は、先ず自分自身に登録されているコンポーネントを探して、見つからない場合は、
includeされている順に子供のS2Containerに登録されているコンポーネントを検索し、最初に見つかったコンポーネントが返されます。
次のような場合は、Foo(自身のコンポーネント)→aaa(子供のS2Container)→bbb(子供のS2Container)の順に検索します。

<pre>&lt;components&gt;
    &lt;include path="aaa.dicon"/&gt;
    &lt;include path="bbb.dicon"/&gt;
    &lt;component class="Foo" /&gt;
&lt;/components&gt;
</pre>

自動で<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>や<a href="#SetterInjection">セッター・インジェクション</a>を行う場合、
S2Containerはインクルード先のコンポーネントを自動インジェクションすることができます。自動でDependency Injectionを行う場合の条件は
<a href="#AutoBindingMode">自動バインディング</a>を参照してください。<br>
次のようにセッター･インジェクションでプロパティに指定するコンポーネントがインクルード先のaaa.diconとbbb.diconに登録されている場合、
各HelloClientでは、どちらのコンポーネントが使用されるかをみてましょう。
<br>
<br>

■ root.dicon
<pre>&lt;components&gt;
    &lt;include path="aaa.dicon"/&gt;
    &lt;include path="bbb.dicon"/&gt;
    &lt;component name="root" class="RootHelloClient"/&gt;
&lt;/components&gt;
</pre>

■ aaa.dicon
<pre>&lt;components&gt;
    &lt;component class="HelloImpl"&gt;
        &lt;property name="message"&gt;"Hello Aaa!"&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name="aaa" class="AaaHelloClient"/&gt;
&lt;/components&gt;
</pre>

■ bbb.dicon
<pre>&lt;components&gt;
    &lt;component class="HelloImpl"&gt;
        &lt;property name="message"&gt;"Hello Bbb!"&lt;/property&gt;
    &lt;/component&gt;

    &lt;component name="bbb" class="BbbHelloClient"/&gt;
&lt;/components&gt;
</pre>

各コンポーネントの内容は、次のようになります。

<pre>&lt;?php
interface HelloClient {
    public function showMessage();
}
?&gt;
</pre>

<pre>&lt;?php
class RootHelloClient implements HelloClient {

    private $hello_;

    public function setHello(Hello $hello) {
        $this->hello_ = $hello;
    }

    public function getHello() {
        return $this->hello_;
    }

    public function showMessage() {
        print $this->getHello()->getMessage();
    }
}
?&gt;
</pre>

AaaHelloClientとBbbHelloClientはRootHelloClient同様の実装です。

<pre>&lt;?php
interface Hello {
    public function setMessage($helloMessage);
    public function getMessage();
}
?&gt;
</pre>

<pre>&lt;?php
class HelloImpl implements Hello {
    private $helloMessage_;

    public function setMessage($helloMessage) {
        $this->helloMessage_ = $helloMessage;
    }

    public function getMessage() {
        return $this->helloMessage_;
    }
}
?&gt;
</pre>

HelloImplはMessageプロパティを定義しているだけです。各HelloClientのshowMessage()を呼び出した
場合の実行結果は次のようになります。
<br><br>
■ RootHelloClientの実行結果
<pre>Hello Aaa!
</pre>
まず、S2Containerはroot.diconにHelloImplが登録されているかを検索します。
root.diconにはないので、次にインクルード先のaaa.diconを検索します。aaa.diconにはHelloImplが登録されているので、
そのコンポーネントを使用します。

<br><br>

■ AaaHelloClientの実行結果
<pre>Hello Aaa!
</pre>

AaaHelloClientは、aaa.diconに登録されているコンポーネントを使用します。自動でインジェクションを行う場合、
子供のS2Containerは親のS2Containerのコンポーネントを使用することはできません。
例えば、root.diconにHelloImplを登録していてもAaaHelloClientには自動インジェクションされないということです。
<br>
<br>

■ BbbHelloClientの実行結果
<pre>Hello Bbb!
</pre>

AaaHelloClientと同様にBbbHelloClientもbbb.diconに登録されているコンポーネントを使用します。
このサンプルは、s2container.php5/examples/dicon/include以下に用意されています。

<a name="Namespace"><h3>名前空間</h3></a>
<p>
　コンポーネントの定義を分割した場合に、複数のコンポーネント定義間で名前が衝突しないように、
<a href="#componentsTag">componentsタグ</a>のnamespace属性で名前空間を指定することができます。
</p>

■ foo.dicon
<pre>&lt;components namespace="foo"&gt;
    &lt;component name="aaa" .../&gt;
    &lt;component name="bbb" ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

■ bar.dicon

<pre>&lt;components namespace="bar"&gt;
    &lt;include path="foo.dicon"/&gt;
    &lt;component name="aaa" .../&gt;
    &lt;component name="bbb" ...&gt;
        &lt;arg&gt;aaa&lt;/arg&gt;
    &lt;/component&gt;
    &lt;component name="ccc" ...&gt;
        &lt;arg&gt;foo.aaa&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

■ app.dicon

<pre>&lt;components&gt;
    &lt;include path="bar.dicon"/&gt;
&lt;/components&gt;
</pre>

同一のコンポーネント定義内では、名前空間なしで参照できます。他のS2Container定義のコンポーネントを参照する場合は、
名前空間.をコンポーネント名の頭につけます。foo.aaaとbar.aaaは同じ名前がついていますが、
名前空間が異なっているので、違うコンポーネントとして認識されます。慣習として、定義ファイルの名前は、
名前空間.diconにすることを推奨します。

<a name="InstanceMode"><h3>インスタンス管理</h3></a>
<p>
　S2Containerで、コンポーネントのインスタンスをどのように管理するのかを指定するのが、
<a href="#componentTag">componentタグ</a>のinstance属性です。デフォルトはsingletonで、
これは S2Container#getComponent()によって返されるコンポーネントは常に同じだという意味です。
S2Container#getComponent()を呼び出すたびに、新たに作成されたコンポーネントを返して欲しい場合は、
instance属性にprototypeを指定します。リクエスト($_REQUEST)ごとにコンポーネントを管理したい場合は、
instance属性にrequestを指定します。セッション($_SESSION)ごとにコンポーネントを管理したい場合は、
instance属性にsessionを指定します。
</p>

<p>
プレゼンテーションのフレームワークと組み合わせるときに、プレゼンテーションフレームワークが作成した
インスタンスに対して、S2Containerで管理されているコンポーネントをセットしたい場合があります。
そのようなS2Container外のコンポーネントに対して<a href="http://www.kakutani.com/trans/fowler/injection.html">Dependency Injection</a>したいときには、
次のメソッドを使用します。

<br><br>
　　- S2Container#injectDependency($outerComponent, $componentKey)<br><br>

第一引数には、外部のコンポーネントを指定します。第二引数には、外部コンポーネントのクラス、
またはコンポーネント名を指定します。そのとき、S2Container定義では、instance属性にouterを指定します。

<br>
<table border="1">
  <tbody><tr align="center" bgcolor="#d1f3f4">
    <th scope="col">instance属性</th>
    <th scope="col">説明</th>
  </tr>
  <tr>
    <td>singleton(default)</td>
    <td>S2Container#getComponent()を何度呼び出しても同じインスタンスが返されます。</td>
  </tr>
  <tr>
    <td>prototype</td>
    <td>S2Container#getComponent()を呼び出すたびに新たなインスタンスが返されます。</td>
  </tr>
  <tr>
<td>request</td>
<td>リクエスト毎に1つのインスタンスが作成されます。name属性に指定した名前で、<br>コンポーネントがリクエストに格納されます。</td>
</tr>
<tr>
<td>session</td>
<td>セッション毎に1つのインスタンスが作成されます。name属性に指定した名前で、<br>コンポーネントがセッションに格納されます。</td>
</tr>
<tr>
  <td>outer</td>
  <td>コンポーネントのインスタンスは、S2Container外で作成し、Dependency Injectionだけを行います。<a href="#Aop">アスペクト</a>、<a href="#ConstructorInjection">コンストラクタ・インジェクション</a>は適用できません。</td>
</tr>
</tbody></table>

<a name="Lifecycle"><h3>ライフサイクル</h3></a>
<p>
　initMethodやdestroyMethodでコンポーネントのライフサイクルもコンテナで管理することができます。
S2Containerの開始時(S2Container#init())に<a href="#initMethodTag">initMethodタグ</a>で指定したメソッドが呼び出され、
S2Containerの終了時(S2Container#destroy())に<a href="#destroyMethodTag">destroyMethodタグ</a>で指定したメソッドが呼び出されるようになります。
initMethodはコンポーネントがコンテナに登録した順番に実行され、destroyMethodはその逆順に呼び出されることになります。
instance属性がsingleton以外の場合、destroyMethodを指定しても無視されます。HashMap#put()メソッドに
初期化(aaaに111を設定)・終了処理(aaaにnullを設定)を設定する場合は、次のようになります。
</p>

<pre>
&lt;components namespace=&quot;bar&quot;&gt;
    &lt;component name=&quot;map&quot; class=&quot;HashMap&quot;&gt;
        &lt;initMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;destroyMethod name=&quot;put&quot;&gt;
            &lt;arg&gt;&quot;aaa&quot;&lt;/arg&gt;
            &lt;arg&gt;null&lt;/arg&gt;
        &lt;/destroyMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<a name="AutoBindingMode"><h3>自動バインディング</h3></a>
<p>
　コンポーネント間の依存関係は、型がインターフェースの場合、コンテナによって自動的に解決されます。
これがS2Containerのデフォルトですが、<a href="#componentTag">componentタグ</a>のautoBinding属性を指定することで細かく制御することもできます。
</p>

<table border="1">
<tbody><tr align="center" bgcolor="#d1f3f4">
<th scope="col">autoBinding</th>
<th scope="col">説明</th>
</tr>
<tr>
<td>auto(default)</td>
<td>
コンストラクタの引数が明示的に指定されている場合は、それに従います。<br>
指定されていない場合、型がインターフェースの場合は自動的にバインドします。<br>
型がインタフェースでない引数にはdefault値を使用します。default値が取得できない場合はnull値を使用します。<br>
プロパティが明示的に指定されている場合はそれに従います。<br>
明示的に指定されていないプロパティで、型がインターフェースの場合は自動的にバインドします。
</td>
</tr>
<tr>
<td>constructor</td>
<td>
コンストラクタの引数が明示的に指定されている場合は、それに従います。<br>
指定されていない場合、型がインターフェースの場合は自動的にバインドします。<br>
型がインタフェースでない引数にはdefault値を使用します。default値が取得できない場合はnull値を使用します。<br>
プロパティが明示的に指定されている場合は、それに従います。</td>
</tr>
<tr>
<td>property</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br>
型がインターフェースのプロパティを自動的にバインドします。</td>
</tr>
<tr>
<td>none</td>
<td>コンストラクタの引数が明示的に指定されている場合は、それに従います。<br>
プロパティが明示的に指定されている場合はそれに従います。</td>
</tr>
</tbody></table>
<br>

<p>
詳しくは、<a href="#AutoConstructorInjectionEx">自動バインディング(コンストラクタ・インジェクション)</a>と
<a href="#AutoSetterInjectionEx">自動バインディング(セッター・インジェクション)</a>を参照してください。
</p>

<a name="UseS2Container"><h3>コンポーネントでS2Containerを利用する</h3></a>
<p>
　コンポーネントはS2Containerに依存しないことが望ましいのですが、コンポーネントによっては、
S2Containerのメソッドを呼び出したい場合もあるでしょう。S2Container自身もcontainerという名前で登録されているので、
arg、propertyタグのボディでcontainerを指定することで、コンテナのインスタンスを取得できます。
また、S2Container型のsetterメソッドを定義しておいて自動バインディングで設定することもできます。
arg、propertyタグでcontainerを指定する場合は、次のようになります。
</p>

<pre>&lt;components&gt;
    &lt;component class="BarImpl"&gt;
        &lt;arg&gt;container&lt;/arg&gt;
    &lt;/component&gt;

    &lt;component class="FooImpl"&gt;
        &lt;property name="foo"&gt;container&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<a name="Aop"><h3>AOPの適用</h3></a>
<p>
　コンポーネントに<a href="aop.html">AOP</a>を適用することもできます。例えば、Dateクラスに<a href="aop.html#TraceInterceptor">TraceInterceptor</a>を
適用したい場合次のようにします。
</p>

<pre>&lt;?php
class Date {
    function Date() {}

    function getTime(){
        return '12:00:30';
    }
}
?&gt;
</pre>

<pre>&lt;components&gt;
    &lt;component name="traceInterceptor"
               class="S2Container_TraceInterceptor"/&gt;
    &lt;component class="Date"&gt;
        &lt;aspect&gt;traceInterceptor&lt;/aspect&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<p>
aspectタグのボディで<a href="aop.html#AOPInterceptor">Interceptor</a>の名前を指定します。
pointcut属性にカンマ区切りで対象となるメソッド名を指定することができます。pointcut属性を指定しない場合は、
コンポーネントが実装しているインターフェースのすべてのメソッドが対象になります。
メソッド名には正規表現も使えます。この定義を使うサンプルは次のようになります。
</p>

<pre>&lt;?php
$PATH ="Aop.dicon";
$container = S2ContainerFactory::create($PATH);
$date = $container->getComponent('Date');
$date->getTime();
?&gt;
</pre>

実行結果は次のようになります。

<pre>BEGIN Date#getTime()
END   Date#getTime() : 12:00:30
</pre>

<a name="Meta"><h3>メタデータ</h3></a>

<p>
　components、component、arg、propertyタグにメタデータ<a href="http://www.seasar.org/aop.html"></a>を指定することもできます。
metaタグはメタデータを指定したいタグの子タグに指定します。例えば、componentsタグにメタデータを指定したい場合次のようにします。
</p>

<pre>&lt;components&gt;
    &lt;meta name="aaa"&gt;111&lt;/meta&gt;
&lt;/components&gt;
</pre>
<p>
components、component、arg、propertyタグに指定したメタデータの情報は、S2Container、ComponentDef、ArgDef、
PropertyDefで定義されている次のメソッドで取得することが出来ます。
</p>

<ul>
<li>public function getMetaDefSize()</li>
<li>public function getMetaDef($name)</li>
</ul>

<br>

</div>

<div class="section">
<h2 id="h03"><a name="DefReference">S2Container定義タグリファレンス</a></h2>

<a name="DOCTYPE"><h3>DOCTYPE</h3></a>
<p>
　DOCTYPEは、XML宣言の次に指定します。下記のように指定してください。
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component name="hello" class="HelloConstructorInjection"&gt;
        &lt;arg&gt;"Hello World!"&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<a name="componentsTag"><h3>componentsタグ(必須)</h3></a>
<p>
　ルートのタグになります。
</p>

<a name="namespaceAttr"><h4>namespace属性(任意)</h4></a>
<p>
　<a href="#Namespace">名前空間</a>を指定することができます。PHPの識別子として使えるものにします。
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components namespace="hoge"&gt;
    ...
&lt;/components&gt;
</pre>

<a name="includeTag"><h3>includeタグ(任意)</h3></a>
<p>
　分割されたS2Containerの定義を<a href="#Include">取り込む</a>場合に使います。
</p>

<a name="pathAttr"><h4>path属性(必須)</h4></a>
<p>
　定義ファイルのパスを指定することができます。componentタグの前に記述する必要があります。
定義ファイルへのパスは絶対パスになります。パスの先頭に%・・・%で囲む事で PHP で定義した定数を指定できます。
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;include path="path/to/ccc.dicon" /&gt;
    &lt;include path="%DICON_DIR%/ddd.dicon" /&gt;
&lt;/components&gt;
</pre>

<a name="componentTag"><h3>componentタグ(任意)</h3></a>
<p>
　コンポーネントを定義します。
</p>

<a name="classAttr"><h4>class属性(任意)</h4></a>
<p>
　クラス名を指定します。ボディで<a href="php.html">PHP式</a>を使ってコンポーネントを指定した場合は、class属性を省略することができます。PHP式を使った場合にclass属性を指定すると、型チェックを行います。
</p>

<a name="componentTag.nameAttr"><h4>name属性(任意)</h4></a>
<p>
　名前を指定することもできます。PHPの識別子として使えるものにします。詳しくは、<a href="#getComponent">コンポーネントの取得</a>を参照してください。
</p>

<a name="instanceAttr"><h4>instance属性(任意)</h4></a>
<p>
　S2Containerがどのようにコンポーネントのインスタンスを管理するのかを指定することができます。singleton(デフォルト)、prototype、outer、request、sessionを指定することができます。詳しくは<a href="#InstanceMode">インスタンス管理</a>を参照してください。
</p>

<a name="autoBindingAttr"><h4>autoBinding属性(任意)</h4></a>
<p>
　S2Containerがコンポーネントの依存関係をどのように解決するのかを指定できます。auto(デフォルト)、constructor、property、noneを指定することができます。詳しくは、<a href="#AutoBindingMode">自動バインディング</a>を参照してください。
</p>

<a name="argTag"><h3>argタグ(任意)</h3></a>
<p>
　<a href="#componentTag">componentタグ</a>の子タグとして使った場合は、コンストラクタの引数になります。記述した順番でコンストラクタに渡されます。
<a href="#initMethodTag">initMethodタグ</a>、<a href="#destroyMethodTag">destroyMethodタグ</a>の子タグとして使った場合は、メソッドの引数になります。記述した順番でメソッドに渡されます。
引数として渡される実際の値は、ボディでPHP式を使うか、子タグで<a href="#componentTag">componentタグ</a>を使います。
</p>

<a name="propertyTag"><h3>propertyタグ(任意)</h3></a>
<p>
　<a href="#componentTag">componentタグ</a>の子タグとして使います。プロパティとして設定される実際の値は、ボディでPHP式を使うか、子タグで<a href="#componentTag">componentタグ</a>を使います。
</p>

<a name="propertyTag.nameAttr"><h4>name属性(必須)</h4></a>
<p>
　プロパティ名を指定します。
</p>

<a name="metaTag"><h3>metaタグ(任意)</h3></a>
<p>
　<a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとして使います。メタデータの値は、ボディでPHPを使うか、子タグで<a href="#componentTag">componentタグ</a>を使います。
</p>

<a name="propertyTag.nameAttr"><h4>name属性(任意)</h4></a>
<p>
　メタ名を指定します。
</p>

<a name="initMethodTag"><h3>initMethodタグ(任意)</h3></a>
<p>
　<a href="#componentTag">componentタグ</a>の子タグとして使います。引数は、子タグで<a href="#argTag">argタグ</a>を使います。name属性を書かずにPHP式を使って、コンポーネントのメソッドを呼び出すこともできます。initMethodタグが定義されているコンポーネント自身を表す$componentがinitMethodタグ内だけで有効なオブジェクトとして使えます。
</p>

<a name="initMethodTag.nameAttr"><h4>name属性(任意)</h4></a>
<p>
　メソッド名を指定します。
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component class="HashMap"&gt;
        &lt;initMethod name="put"&gt;
            &lt;arg&gt;"aaa"&lt;/arg&gt;
            &lt;arg&gt;111&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;$component->put(&quot;aaa&quot;, 111);&lt;/initMethod&gt;
        &lt;initMethod&gt;print &quot;Hello&quot;;&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<a name="destroyMethodTag"><h3>destroyMethodタグ(任意)</h3></a>
<p>
　initMethodタグと同様です。
</p>

<a name="aspectTag"><h3>aspectタグ(任意)</h3></a>
<p>
　アスペクトをコンポーネントに組み込みます。詳しくは、<a href="aop.html#AOPExplanationFile">aspectタグ</a>の説明を参照してください。
</p>

<a name="interTypeTag"><h3>interTypeタグ(任意)</h3></a>
<p>
　インタータイプをコンポーネントに組み込みます。詳しくは、S2AOPの<a href="aop.html#interTypeTag">interTypeタグ</a>の説明を参照してください。
</p>

<a name="descriptionTag"><h3>descriptionタグ(任意)</h3></a>
<p>
　<a href="#componentsTag">componentsタグ</a>、<a href="#componentTag">componentタグ</a>、<a href="#argTag">argタグ</a>、<a href="#propertyTag">propertyタグ</a>の子タグとしてdescriptionタグを使うことができます。自由に説明を記述できます。
</p>

<br>

</div>

<!-- ######################################################### -->
<div class="section">
<h2 id="h03"><a name="constant-def">S2Containerで使用される定数</a></h2>

<a name="const-dom-valid"><h3>S2CONTAINER_PHP5_DOM_VALIDATE</h3></a>
<p>
　ダイコンファイルを読み込む際に、DTD検証を実施するかどうかをbool値で指定します。<br>
　 - デフォルト値 ： true 
</p>

<a name="const-app-dicon"><h3>S2CONTAINER_PHP5_APP_DICON</h3></a>
<p>
　S2Container_SingletonS2ContainerFactorが使用するダイコンファイル指定します。<br>
　 - デフォルト値 ： 未定義
</p>

<a name="const-log-level"><h3>S2CONTAINER_PHP5_LOG_LEVEL</h3></a>
<p>
　S2Container.PHP5のログレベルを定義します。S2Container.PHP5 の S2Container_SimpleLoggerクラスのログレベルには、DEBUG、INFO、WARN、ERROR、FATAL があります。<br>
　 - デフォルト値 ： S2Container_SimpleLogger::WARN
</p>

<a name="const-log-eval"><h3>S2CONTAINER_PHP5_DEBUG_EVAL</h3></a>
<p>
　S2Container.PHP5のログレベルが DEBUG の場合に、eval関数で実行されるスクリプトを出力するかどうかをbool値で指定します。<br>
　 - デフォルト値 ： false
</p>

<a name="const-log-file"><h3>S2CONTAINER_PHP5_SIMPLE_LOG_FILE</h3></a>
<p>
　S2Container_SimpleLoggerのログ出力先ファイルを指定します。<br>
　 - デフォルト値 ： 未定義 (stdout)
</p>

<a name="const-anno"><h3>S2CONTAINER_PHP5_ANNOTATION_HANDLER</h3></a>
<p>
　アノテーションタイプをクラス名で指定します。(S2Container_ConstantAnnotationHandler または S2Container_CommentAnnotationHandler)<br>
　 - デフォルト値 ： S2Container_ConstantAnnotationHandler
</p>

<a name="const-env"><h3>S2CONTAINER_PHP5_ENV</h3></a>
<p>
　環境指定を行います。この値は、ダイコンファイルを読み込む際に、ダイコンファイルのSuffixとして使用されます。<br>
S2CONTAINER_PHP5_ENV が test と定義されていて、foo.dicon と foo_test.diconが存在した場合、foo_test.diconが
使用されます。<br>
　 - デフォルト値 ： 未定義
</p>

</div>
<br>

<!-- ######################################################### -->
<div class="section">
<h2 id="h03"><a name="Example">Example</a></h2>
<p>
　以下のサンプルを実行する場合は、<a href="setup.html">セットアップ</a>を行う必要があります。
</p>

<a name="ConstructorInjectionEx"><h3>コンストラクタ・インジェクション</h3></a>
<p>
　コンストラクタ・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。
</p>

<ul>
    <li type="circle">インターフェース(Hello.class.php)</li>
    <li type="circle">実装クラス(HelloConstructorInjection.class.php)</li>
    <li type="circle">diconファイル(HelloConstructorInjection.dicon)</li>
    <li type="circle">実行スクリプト(HelloConstructorInjectionClient.php)</li>
</ul>

<h5>インターフェースの作成</h5>
<ul>
    <li type="circle">showMessage()を定義します。</li>
</ul>

<p
>先ず最初はインターフェースを考えます。インターフェースと実装を分離することで、コンポーネントの利用者は、
インターフェースを知っていれば実装のことは知らなくても済むようになります。
また、テストの時には実装をモックに置き換えることで簡単にテストできるようになります。
</p>

<pre>&lt;?php
interface Hello {
    public function showMessage();
}
?&gt;
</pre>

<h5>実装クラスの作成</h5>

<ul>
    <li type="circle">引数が1つのンストラクタを定義します。</li>
    <li type="circle">showMessage()を実装します。</li>
</ul>

<p>
次はいよいよ実装です。コンストラクタでメッセージを受け取り、showMessage()で受け取ったメッセージを出力します。
</p>

<pre>&lt;?php
class HelloConstructorInjection implements Hello {
    private $message;

    public function HelloConstructorInjection($message) {
        $this->message = $message;
    }

    public void showMessage() {
        print $this->message . "\n";
    }
}
?&gt;
</pre>

<h5>diconファイルの作成</h5>

<ul>
    <li type="circle"><a href="#componentTag">componentタグ</a>でコンポーネントを定義します。</li>
    <li type="circle">componentタグの子タグの<a href="#argTag">argタグ</a>でコンストラクタの引数値を定義します。</li>
</ul>

<p>
メッセージをコンポーネントに設定するのは、S2Containerの仕事です。定義ファイルに基づいてコンポーネントを組み立てます。<br><br>
s2container.php5/examples/dicon/injection/HelloConstructorInjection.dicon
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component name="hello" class="HelloConstructorInjection"&gt;
        &lt;arg&gt;"Hello World!"&lt;/arg&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h5>実行スクリプトの作成</h5>

<ul>
    <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory#create($path)を呼び出してS2Containerを作成します</a>。</li>
    <li type="circle">getComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
    <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
</ul>

<p>
s2container.php5/examples/dicon/injection/HelloConstructorInjectionClient.php
</p>

<pre>&lt;?php
require_once(dirname(dirname(dirname(__FILE__))) . '/example.inc.php');
require_once('Hello.class.php');
require_once('HelloConstructorInjection.class.php');

$PATH =	EXAMPLE_DIR . "/dicon/injection/HelloConstructorInjection.dicon";

$container = S2ContainerFactory::create($PATH);
$hello = $container->getComponent('Hello');
$hello->showMessage();

$hello2 = $container->getComponent("hello");
$hello2->showMessage();
?&gt;
</pre>

<h5>実行結果</h5>
<p>
argタグで指定した文字列が正しく表示されていることが確認できます。
</p>

<pre>% php HelloConstructorInjectionClient.php
Hello World!
Hello World!
%
</pre>

<p>
この演習は、s2container.php5/examples/dicon/injection以下に用意されています。
</p>

<a name="SetterInjectionEx"><h3>セッター・インジェクション</h3></a>
<p>
　セッター・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。
</p>

<ul>
    <li type="circle">インターフェース(Hello.class.php)</li>
    <li type="circle">実装クラス(HelloSetterInjection.class.php)</li>
    <li type="circle">diconファイル(HelloSetterInjection.dicon)</li>
    <li type="circle">実行スクリプト(HelloSetterInjectionClient.php)</li>
</ul>

<h5>インターフェースの作成</h5>
<ul>
    <li type="circle">showMessage()を定義します。</li>
</ul>

<p>
インターフェースはコンストラクタ・インジェクションの場合と同じです。プロパティに対するゲッター・メソッド、
セッター・メソッドを定義する必要はありません。なぜなら、Dependency Injectionするのにコンストラクタを使うのか
セッター・メソッドを使うのかは実装の問題だからです。 
</p>

<pre>&lt;?php
interface Hello {
    public void showMessage();
}
?&gt;
</pre>

<h5>実装クラスの作成</h5>

<ul>
    <li type="circle">セッター・メソッド(setMessage)を定義します。</li>
    <li type="circle">showMessage()を実装します。</li>
</ul>

<p>
次は実装です。セッター・メソッドでメッセージを受け取り、showMessage()で受け取ったメッセージを出力します。
</p>

<pre>&lt;?php
class HelloSetterInjection implements Hello {
    private $message;

    public function HelloSetterInjection() {
    }

    public function setMessage($message) {
        $this->message = $message;
    }

    public function showMessage() {
        print $this->message . "\n";
    }
}
?&gt;
</pre>

<h5>diconファイルの作成</h5>

<ul>
    <li type="circle">componentタグでコンポーネントを定義します。</li>
    <li type="circle">componentタグの子タグの<a href="#propertyTag">propertyタグ</a>でコンポーネントのプロパティ値を定義します。</li>
</ul>

<p>
s2container.php5/examples/dicon/injection/HelloSetterInjection.dicon
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component class="HelloSetterInjection"&gt;
        &lt;property name="message"&gt;"Hello World!"&lt;/property&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h5>実行スクリプトの作成</h5>

<ul>
    <li type="circle">S2ContainerFactory#create($path)を呼び出してS2Containerを作成します。</li>
    <li type="circle">getComponent()を使用して、S2Containerからコンポーネントを取り出します。</li>
    <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
</ul>

<p>
s2container.php5/examples/dicon/injection/HelloSetterInjectionClient.php
</p>

<pre>&lt;?php
require_once(dirname(dirname(dirname(__FILE__))) . '/example.inc.php');
require_once('Hello.class.php');
require_once('HelloSetterInjection.class.php');

$PATH = EXAMPLE_DIR . "/dicon/injection/HelloSetterInjection.dicon";

$container = S2ContainerFactory::create($PATH);
$hello = $container->getComponent('Hello');
$hello->showMessage();
?&gt;
</pre>

<h5>実行結果</h5>
<p>
propertyタグで指定した文字列が正しく表示されていることが確認できます。
</p>

<pre>% php HelloSetterInjectionClient.php
Hello World!
%
</pre>

<p>
この演習は、s2container.php5/examples/dicon/injection以下に用意されています。
</p>

<a name="MethodInjectionEx"><h3>メソッド・インジェクション</h3></a>
<p>
　メソッド・インジェクションを使ってメッセージを表示しましょう。作成するファイルは以下のとおりです。
</p>

<ul>
    <li type="circle">インターフェース(Hello.class.php)</li>
    <li type="circle">実装クラス(HelloMethodInjection.class.php)</li>
    <li type="circle">diconファイル(HelloMethodInjection.dicon)</li>
    <li type="circle">実行スクリプト(HelloMethodInjectionClient.php)</li>
</ul>

<h5>インターフェースの作成</h5>
<ul>
    <li type="circle">showMessage()を定義します。</li>
</ul>

<p>
追加のメソッドを複数回呼び出すようなケースが代表的な使い方ですが、今回の演習では、インターフェースはコンストラクタ・インジェクションの場合と同じにしました。
</p>

<pre>&lt;?php
interface Hello {
    public function showMessage();
}
?&gt;
</pre>

<h5>実装クラスの作成</h5>

<ul>
    <li type="circle">addMessage()を定義します。</li>
    <li type="circle">showMessage()を実装します。</li>
</ul>

<p>
次は実装です。addMessage($message)でメッセージを複数回追加して、showMessage()で受け取ったメッセージを出力します。
</p>

<pre>&lt;?php
class HelloMethodInjection implements Hello {

    private $buf = "";

    public function HelloMethodInjection() {}

    public function addMessage($message) {
        $this->buf .= $message;
    }

    public function showMessage() {
        print $this->buf . "\n";
    }
}
?&gt;
</pre>

<h5>diconファイルの作成</h5>

<ul>
    <li type="circle">componentタグでコンポーネントを定義します。</li>
    <li type="circle">componentタグの子タグの<a href="#initMethodTag">initMethodタグ</a>でコンポーネントのメソッドの引数値を定義します。</li>
</ul>

<p>
先ずは、argタグを使ってaddMessage($message)に"Hello "を指定します。<br>次にPHP式を使ってaddMessage($message)に"World！"を指定します。<br><br>
s2container.php5/examples/dicon/injection/HelloMethodInjection.dicon
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component class="HelloMethodInjection"&gt;
        &lt;initMethod name="addMessage"&gt;
            &lt;arg&gt;"Hello "&lt;/arg&gt;
        &lt;/initMethod&gt;
        &lt;initMethod&gt;$component->addMessage("World!")&lt;/initMethod&gt;
    &lt;/component&gt;
&lt;/components&gt;
</pre>

<h5>実行スクリプトの作成</h5>

<ul>
    <li type="circle">S2ContainerFactory#create($path)を呼び出してS2Containerを作成します。</li>
    <li type="circle">getComponent()を使用して、S2Containerからコンポーネントを取り出します。</li>
    <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
</ul>

<pre>&lt;?php
require_once(dirname(dirname(dirname(__FILE__))) . '/example.inc.php');
require_once('Hello.class.php');
require_once('HelloMethodInjection.class.php');

$PATH = EXAMPLE_DIR . "/dicon/injection/HelloMethodInjection.dicon";

$container = S2ContainerFactory::create($PATH);
$hello = $container->getComponent('Hello');
$hello->showMessage();
?&gt;
</pre>

<h5>実行結果</h5>

<p>
initMethodタグで指定した文字列が正しく表示されていることが確認できます。
</p>

<pre>% php HelloMethodInjectionClient.php
Hello World!
%
</pre>

<p>
この演習は、s2container.php5/examples/dicon/injection/以下に用意されています。
</p>

<a name="AutoConstructorInjectionEx"><h3>自動バインディング(コンストラクタ・インジェクション)</h3></a>

<p>
　自動バインディングでメッセージを表示してみましょう。作成するファイルは以下のとおりです。
</p>

<ul>
    <li type="circle">インターフェース(Hello.class.php)</li>
    <li type="circle">インターフェースの実装クラス(AutoHelloConstructorInjection.class.php)</li>
    <li type="circle">Mapインターフェース(Map.class.php)</li>
    <li type="circle">Mapインターフェースの実装クラス(HashMap.class.php)</li>
    <li type="circle">diconファイル(AutoHelloConstructorInjection.dicon)</li>
    <li type="circle">実行スクリプト(AutoHelloConstructorInjectionClient.php)</li>
</ul>

<h5>インターフェースの作成</h5>
<ul>
    <li type="circle">showMessage()を定義します。</li>
</ul>

<pre>&lt;?php
interface Hello {
    public function showMessage();
}
?&gt;
</pre>

<h5>実装クラスの作成</h5>

<ul>
    <li type="circle">引数がMapのコンストラクタを定義します。</li>
    <li type="circle">showMessage()を実装します。</li>
</ul>

<p>
コンストラクタでMapを受け取り、showMessage()でhelloをキーとしてMapから値を取得して出力します。
</p>

<pre>&lt;?php
class AutoHelloConstructorInjection implements Hello {

    private $messages;

    public function AutoHelloConstructorInjection(Map $messages) {
        $this->messages = $messages;
    }

    public function showMessage() {
        print $this->messages->get('hello') . "\n";
    }
}
?&gt;
</pre>

<h5>Mapインターフェースの作成</h5>

<ul>
    <li type="circle">put($key,$val)を定義します。</li>
    <li type="circle">get($key)を定義します。</li>
</ul>

<pre>&lt;?php
interface Map {
    function put($key,$val);
    function get($key);
}
?&gt;
</pre>

<h5>Mapインターフェースの実装クラスの作成</h5>

<ul>
    <li type="circle">引数がMapのコンストラクタを定義します。</li>
    <li type="circle">showMessage()を実装します。</li>
</ul>

<pre>&lt;?php
class HashMap implements Map{
    private $pool = array();

    function HashMap() {}

    function put($key,$val){
        $this->pool[$key] = $val;
    }

    function get($key){
        return array_key_exists($key,$this->pool) ? $this->pool[$key] : null;
    }
}
?&gt;
</pre>

<h5>diconファイルの作成</h5>

<ul>
    <li type="circle"><a href="#componentTag">componentタグ</a>でMapの実装クラスであるHashMapをコンポーネント定義します。</li>
    <li type="circle">componentタグの子タグである<a href="#initMethodTag">initMethodタグ</a>でHashMapにキーとして"hello"、値として"Hello World!"を定義します。</li>
    <li type="circle">componentタグでAutoHelloConstructorInjectionをコンポーネント定義します。autoBinding属性にautoを指定します。演習であるため auto を明示的に指定していますが、autoBinding属性のデフォルト値であるため本来は省略します。</li>
</ul>

<p>
AutoHelloConstructorInjectionには、argタグが定義されていないことに注目してください。コンストラクタ・インジェクションを行う場合、
argタグを定義する必要がありますが、S2Container内にMapの実装クラスが登録されていれば、S2Containerがコンテナ内を検索して
自動的に引数を設定します。ただし、引数の型がインターフェースでない場合、自動バインディングはできません。<br><br>
s2container.php5/examples/dicon/autobinding/AutoHelloConstructorInjection.dicon
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component class="HashMap"&gt;
        &lt;initMethod name="put"&gt;
            &lt;arg&gt;"hello"&lt;/arg&gt;
            &lt;arg&gt;"Hello World!"&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;

    &lt;component autoBinding="auto"
               class="AutoHelloConstructorInjection"/&gt;
&lt;/components&gt;
</pre>

<h5>実行スクリプトの作成</h5>

<ul>
    <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory#create($path)を呼び出してS2Containerを作成します</a>。</li>
    <li type="circle">getComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
    <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
</ul>

<pre>&lt;?php
require_once(dirname(dirname(dirname(__FILE__))) . '/example.inc.php');
require_once('Hello.class.php');
require_once('Map.class.php');
require_once('HashMap.class.php');
require_once('AutoHelloConstructorInjection.class.php');

$PATH =	EXAMPLE_DIR . "/dicon/autobinding/AutoHelloConstructorInjection.dicon";

$container = S2ContainerFactory::create($PATH);
$hello = $container->getComponent('Hello');
$hello->showMessage();
?&gt;
</pre>

<h5>実行結果</h5>

<p>
HashMapの値が表示されていることから、自動的にコンストラクタの引数を設定していることが確認できます。
</p>

<pre>% php AutoHelloConstructorInjection.php
Hello World!
%
</pre>

<p>
この演習は、s2container.php5/examples/dicon/autobinding以下に用意されています。
</p>

<a name="AutoSetterInjectionEx"><h3>自動バインディング(セッター・インジェクション)</h3></a>

<p>
　自動バインディングでメッセージを表示してみましょう。作成するファイルは以下のとおりです。
</p>

<ul>
    <li type="circle">インターフェース(Hello.class.php)</li>
    <li type="circle">インターフェースの実装クラス(AutoHelloSetterInjection.class.php)</li>
    <li type="circle">diconファイル(AutoHelloSetterInjection.dicon)</li>
    <li type="circle">実行スクリプト(AutoHelloSetterInjectionClient.php)</li>
</ul>

<h5>インターフェースの作成</h5>
<ul>
    <li type="circle">showMessage()を定義します。</li>
</ul>

<pre>&lt;?php
interface Hello {
    public function showMessage();
}
?&gt;
</pre>

<h5>実装クラスの作成</h5>

<ul>
    <li type="circle">引数がMapのshowMessage()を実装します。</li>
</ul>

<p>
setMessage(Map map)でMapを受け取り、showMessage()でhelloをキーとしてMapから値を取得して出力します。
</p>

<pre>&lt;?php
class AutoHelloSetterInjection implements Hello {

    private $messages;

    public function AutoHelloSetterInjection() {}

    public function setMessage(Map $messages) {
        $this->messages = $messages;
    }

    public function showMessage() {
        print $this->messages->get('hello') . "\n";
    }
}
?&gt;
</pre>

<h5>diconファイルの作成</h5>

<ul>
    <li type="circle"><a href="#componentTag">componentタグ</a>でMapの実装クラスであるHashMapをコンポーネント定義します。</li>
    <li type="circle">componentタグの子タグである<a href="#initMethodTag">initMethodタグ</a>でHashMapにキーとして"hello"、値として"Hello World!"を定義します。</li>
    <li type="circle">componentタグでAutoHelloSetterInjectionをコンポーネント定義します。autoBinding属性にautoを指定します。<br>演習であるため auto を明示的に指定していますが、autoBinding属性のデフォルト値であるため本来は省略します。</li>
</ul>

<p>
AutoHelloSetterInjectionには、propertyタグが定義されていないことに注目してください。セッター・インジェクションを行う場合、
propertyタグで任意のプロパティを定義する必要がありますが、S2Container内にMapの実装クラスが登録されていれば、
S2Containerがコンテナ内を検索して自動的にプロパティを設定します。ただし、プロパティの型がインターフェースでない場合、
自動バインディングはできません。<br><br>
s2container.php5/examples/dicon/autobinding/AutoHelloSetterInjection.dicon
</p>

<pre>&lt;?xml version="1.0" encoding="Shift_JIS"?&gt;
&lt;!DOCTYPE components PUBLIC "-//SEASAR2.1//DTD S2Container//EN"
"http://www.seasar.org/dtd/components21.dtd"&gt;
&lt;components&gt;
    &lt;component class="HashMap"&gt;
        &lt;initMethod name="put"&gt;
            &lt;arg&gt;"hello"&lt;/arg&gt;
            &lt;arg&gt;"Hello World!"&lt;/arg&gt;
        &lt;/initMethod&gt;
    &lt;/component&gt;

    &lt;component autoBinding="auto"
               class="AutoHelloSetterInjection"/&gt;
&lt;/components&gt;
</pre>

<h5>実行スクリプトの作成</h5>

<ul>
    <li type="circle"><a href="#S2ContainerCreation">S2ContainerFactory#create($path)を呼び出してS2Containerを作成します</a>。</li>
    <li type="circle">getComponent()を使用して、<a href="#getComponent">S2Containerからコンポーネントを取り出します</a>。</li>
    <li type="circle">取得したコンポーネントのメソッドを呼び出します。</li>
</ul>

<pre>&lt;?php
require_once(dirname(dirname(dirname(__FILE__))) . '/example.inc.php');
require_once('Hello.class.php');
require_once('Map.class.php');
require_once('HashMap.class.php');
require_once('AutoHelloSetterInjection.class.php');

$PATH = EXAMPLE_DIR . "/dicon/autobinding/AutoHelloSetterInjection.dicon";

$container = S2ContainerFactory::create($PATH);
$hello = $container->getComponent('Hello');
$hello->showMessage();
?&gt;
</pre>

<h5>実行結果</h5>

<p>
HashMapの値が表示されていることから、自動的にプロパティを設定していることが確認できます。
</p>

<pre>% php AutoHelloSetterInjection.php
Hello World!
%
</pre>

<p>
この演習は、s2container.php5/examples/dicon/autobinding以下に用意されています。
</p>
<br>

</div>
</div><!-- article -->

</div><!-- contents_center -->

<div id="footer">
<address>&#169; Copyright The Seasar Foundation and the others 2005-2007, all rights reserved.</address>
<div class="line"><span class="hide">spacer</span></div>
</div><!-- footer -->

</div><!-- wrapper -->

</body></html>